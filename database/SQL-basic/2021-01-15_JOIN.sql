-- JOIN : 여러 테이블에 대한 조인 검색(병합검색)
-- 조인 속성 : 조인 검색을 위해 테이블을 연결해주는 속성(양쪽 테이블에서 공통으로 나타나는 속성)
-- 보통 조인 속성은 한쪽의 테이블에서 외래키로 지정되어 있다.
-- 연결하려는 테이블 간에 조인속성은 이름은 달라도 되지만, 도메인은 같아야 함.

-- 조인 형식
-- FROM 검색에 필요한 모든 테이블을 나열
-- WHERE 조인 속성의 값이 같아야 함을 의미하는 조건 제시
-- 같은 이름의 속성이 서로 다른 테이블에 존재할 수 있기 때문에, 
-- 속성 이름 앞에 해당 속성이 소속된 테이블의 이름을 표시함.
-- EX. 주문.주문고객 = 고객.고객아이디


-- 판매 데이터베이스에서 banana 고객이 주문한 제품의 이름을 확인

SELECT 제품.제품명
FROM 주문, 제품
WHERE 주문.`주문제품` = 제품.`제품번호` AND
		주문.주문고객 = 'banana';
		
-- 판매 데이터베이스에서 나이가 30세 이상인 고객이
-- 주문한 제품의 주문제품과 주문일자를 확인

SELECT 주문.`주문제품`, 주문.`주문일자`
FROM 고객, 주문
WHERE 고객.`고객아이디` = 주문.`주문고객` AND
		고객.나이 >= 30
;

-- 테이블의 이름을 대신하는 ailas를 제시해 질의문을 작성하는 것이 일반적
SELECT c.`주문제품`, o.`주문일자`
FROM 고객 c, 주문 o
WHERE c.`고객아이디` = o.`주문고객` AND
		c.나이 >= 30
;

-- 테이블 세 개 이상에 대하여 조인
-- 판매 데이터베이스에서 고명석 고객이 주문한 제품의 제품명을 검색

SELECT p.`제품명`
FROM 고객 c, 제품 p, 주문 o 
WHERE c.`고객아이디` = o.`주문고객` AND 
		p.`제품번호` = o.`주문제품` AND 
		c.`고객이름` = '고명석'
;


-- Sub Query (부속 질의문)
-- SELECT 문 안에 또 다른 SELECT 문을 포함하는 질의문
-- 상위 질의문(주 질의) : 다른 SELECT 문을 포함하는 SELECT 문
-- 부속 질의문(부속 질의) : 다른 SELECT 안에 들어있는 SELECT 문
	-- 괄호로 묶어서 작성, ORDER BY 절을 사용할 수 없음.
	-- 단일행 부속질의 : 하나의 행을 결과로 반환
	-- 다중행 부속질의 : 하나 이상의 행을 결과로 반환
-- 부속질의가 먼저 실행되고, 그 결과를 바탕으로 상위질의문이 실행된다
-- 부속질의문과 상위질의문을 연결하는 연산자가 필요함.
	-- 단일행 부속질의는 비교연산자(=, <>, >=, <=) 사용 가능
	-- 다중행 부속질의는 비교연산자 사용 불가
	
-- - 단일행 부속질의
-- 1. 판매 데이터베이스에서 '달콤비스킷'을 생산한 제조업체가 만든 제품들의 제품명과 단가를 확인
SELECT * FROM 제품;

-- 1) '달콤비스킷'을 만든 업체를 찾고 (한빛제과) : 부속질의
-- 2) 한빛제과가 만든 제품명 단가 : 상의질의

SELECT 제품명, 단가
FROM 제품
WHERE 제조업체 = (SELECT 제조업체
		FROM 제품
		WHERE 제품명 = '달콤비스킷');
		
		
-- 2. 판매 데이터베이스에서 적립금이 가장 많은 고객의 고객 이름과 적립금을 검색
-- 집계함수와 일반속성을 같이 사용했기때문에, 논리적 오류 발생
SELECT 고객이름, MAX(적립금)
FROM 고객;

SELECT * FROM 고객; 

SELECT 고객이름, 적립금
FROM 고객
WHERE 적립금 = (SELECT max(적립금) FROM 고객);

-- - 다중행 부속질의

-- IN 예제
-- 1. banana 고객이 주문한 제품의 제품명과 제조업체
	-- 1) banana가 주문한 제품 확인 : Sub Query
	-- 2) 그 제품의 제품명과 제조업체 : Main Query

/*
SELECT 제품명, 제조업체
FROM 제품
WHERE 제품번호 = (SELECT 주문제품
		FROM 주문
		WHERE 주문고객 = 'banana');
*/ 
-- 서브쿼리가 다중 행을 반환하므로 비교연산자를 사용하면 오류가 나게 됨.

-- 다중행 부속 질의문에 사용 가능한 연산자
-- IN / NOT IN / EXISTS / NOT EXISTS / ALL / ANY or SOME


SELECT 제품명, 제조업체
FROM 제품
WHERE 제품번호 IN 
		(SELECT 주문제품
		FROM 주문
		WHERE 주문고객 = 'banana');
		
-- NOT IN 예제
-- 2. 판매 데이터베이스에서 banana 고객이 주문하지 않은 제품의 제품명과 제조업체를 확인
-- banana 고객이 주문한 제품을 추출한 후 그 제품이 아닌 나머지 제품에 대해서 출력
SELECT 제품명, 제조업체
FROM 제품
WHERE 제품번호 NOT IN 
		(SELECT 주문제품
		FROM 주문
		WHERE 주문고객 = 'banana')
		;

-- ALL 예제
-- 3. 판매 데이터베이스에서 대한식품이 제조한 모든 제품의 단가보다 비싼 제품의 제품명, 단가, 제조업체를 검색
	-- 1) 대한식품에서 제조한 제품의 단가
SELECT 단가
FROM 제품
WHERE 제조업체 = '대한식품'


	-- 2) ALL 연산자 사용 - 부속질의가 반환하는 값의 비교연산자를 모두 만족하는 값
SELECT 제품명, 단가, 제조업체
FROM 제품
WHERE 단가 > ALL(SELECT 단가
		FROM 제품
		WHERE 제조업체 = '대한식품')
;

-- ANY 예제
-- 부속질의가 반환하는 값의 비교연산자를 하나라도 만족하는 값
SELECT 제품명, 단가, 제조업체
FROM 제품
WHERE 단가 > ANY(SELECT 단가
		FROM 제품
		WHERE 제조업체 = '대한식품')
;

-- EXISTS : 부속질의문의 결과값이 하나라도 존재하면
-- NOT EXISTS : 부속 질의문의 결과값이 하나도 존재하지 않으면

-- EXSITS / NOT EXISTS 예제
-- 1. 판매 데이터베이스에서 2019년 3월 15일에 제품을 주문한 고객의 고객이름을 검색
	-- 1) 2019년 3월 15일에 제품을 주문한 고객
SELECT *
FROM 주문
WHERE 주문일자='2019-03-15';

	-- 2) 주문고객 필드 값을 이용해서 고객테이블에서 이름을 확인
SELECT 고객이름
FROM 고객
WHERE EXISTS (SELECT *
					FROM 주문
					WHERE 주문일자 = '2019-03-15' AND
					주문.주문고객 = 고객.고객아이디) 
;

-- 2. 판매 데이터베이스에서 2019년 3월 15일에 제품을 '주문하지 않은' 고객의 고객이름을 검색
SELECT 고객이름
FROM 고객
WHERE NOT EXISTS (SELECT *
					FROM 주문
					WHERE 주문일자 = '2019-03-15' AND
					주문.주문고객 = 고객.고객아이디) 
;
